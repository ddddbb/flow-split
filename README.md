# flow-split
flow-split是一个接口的分流和流控的门面项目，包括以下子项目
   + flow-split-manager
   + dubbo
   + grpc
   + rocketmq
   + ......
   
 
 

# 为重构而生

我们过去重构实践最大的问题不是重构，而是业务的平滑迁移。平滑迁移要求系统架构要按照肉夹馍的方式来。
<img  src= 'image/rjm.bmp' width = "500" height = "400"  >

**举个例子**

不能保证上层系统/接口/迁移的进度，必须保证对遗留接口，同时必须保证被重构的系统的灰度。

被重构系统既然灰度，不能完全下线；并且也不重构遗留系统——这样会让风险和进度更难控制——那么数据库也最好不要动。

在上下两层不变的系统情况下，既要兼容遗留接口，又要兼容遗留数据库。这样的升级方案是最稳妥的。

但是重构系统又想一步到位



**可以这么来**

1，设计一个理想实现

2，针对遗留接口，增加一个接口适配器层

3，针对遗留数据库，增加数据库适配器层

4，新老系统同时运行，将理想接口释放出去，并针对遗留接口制定一个迁移计划

5，制定数据库迁移计划，开发新的数据库适配器层。

我们可以看到，在这中间，最关键的一步是新老系统同时运行的机制。即新老系统分流，控流。
 
（这么来的前提是被重构系统和重构后系统，在业务语义上是完全等价的）

<img  src= 'image/refact_update.bmp' width = "500" height = "400"  >


# 原理
以为dubbo为例
在consumer 向 provider invoke的过程中
1，（根据**分流表达式**）筛选符合条件的实现
2，（根据**流控表达式**）负载均衡

例子
定义了符合条件的provider。
例如某金融系统已经有1个招行支付渠道CMB1,又接入了一个CMB2，为新渠道制定分离规则
:交易金额小于2元钱，切1%流量。

分流，流控表达式：request.amount < 2, 1%


# 实现设计
以dubbo例，可知道无论是分流还是流控，其实dubbo的既有机制都支持。但是要每个接口都能基于特定的表达式则需要扩展。

所以，核心的是为dubbo扩展基于这两种表达式的实现。

以rocketmq为例，rocketmq需要将filter服务器部署起来，才能实现这种扩展机制。其他mq暂时还不支持这种基于机制。


## 机制
 - dubbo，grpc，或者rocket的分流扩展从规则库加载规则
 - 对应接口被call的时候，激活这些规则，并分流，流控











